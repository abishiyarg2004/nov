// LEX ANALYSER USING C
#include<string.h>
#include<ctype.h>
#include<stdio.h>
void main()
{
	FILE *f1,*f2,*f3,*f4;
	char c,str[10],st1[10];
	int num[100],tokenvalue=0,i=0,j=0,k=0;
	char keywords[10][10]= {"int","float","char","while","do","for","if"};
	
	f1=fopen("input","w");
	while((c=getchar())!=EOF){
		putc(c,f1);
	}
	
	f1=fopen("input.txt","r");
	f2=fopen("identifier.txt ","w");
	f3=fopen("specialchar.txt ","w");
	f4=fopen("operators.txt ","w");
	
	while((c=getc(f1))!=EOF)
	{
		if(isdigit(c)) {
			while(isdigit(c))
			{
				tokenvalue*=10+c-'0';
				c=getc(f1);
			}
			num[i++]=tokenvalue;
		}
		else if(isalpha(c))
		{
			while(isdigit(c)||isalpha(c)||c=='_'||c=='$')
			{
				putc(c,f2);
				c=getc(f1);
			}
		}
		else if(c=='+' || c=='-' ||c=='*' ||c=='<'||c=='>'||c=='/'||c=='&'||c=='%' ||c=='^' ||c== '='){
			putc(c,f4);
		}
		else{
			putc(c,f3);
		}
	}
	
	printf("\nThe constants are ");
	for(j=0; j<i; j++){
		printf("%d",num[j]);
	}

	printf("The keywords and identifiers are:");
	while((c=getc(f2))!=EOF)
	{
	    if(!strcmp(*keywords,str)){
	        printf("\n%s is a keyword",str);
	    }
	    else{
	    	printf("\n%s is an identifier",str);
	    }
	}

	printf("\nSpecial characters are ");
	while((c=getc(f3))!=EOF){
		printf("%c ",c);
	}

	printf("Operators are ");
	while((c=getc(f4))!=EOF){
		printf("%c ",c);
	}

}





// IMPLEMENTATION OF SYMBOL TABLE
#include<stdio.h>
#include<ctype.h>
#include<string.h>
struct symtab{
	int lineno;
	char var[25],dt[25],val[10];
} sa[20];

void main()
{
	int i=0,j,k,max,f=0,xx,h,m,n,l,r,ty=1,m1,line=0;
	char s[25],typ[25],temp[25],gar[]="garbage",t[25],got[10],e[10];
	float m2;
	FILE *fn,*ft,*fp
	
	fn=fopen("input.txt","r");
	printf("\n\nSYMBOL TABLE MANAGEMENT\n\n");
	printf("Variable\tDatatype\tLine.no.\t\tValue\n");
	
	while(!(feof(fn))){
		fscanf(fn,"%s",s);
		line++;
		while(s,";"!=0){
			i++;
		}
		max=i;
		sa[i].lineno=line;
		fscanf(fn,"%s",s);
		strcpy(sa[i].var,s);
		if(strcmp(s,"=")==0){
			fscanf(fn,"%s",s);
			strcpy(sa[i].val,s);
		}
		else{
			strcpy(sa[i].val,gar);
		}
		if(strcmp(s,",")==0){
			continue;
		}
		else if(strcmp(s,"char")==0{
			strcpy(typ,s);
			line++;
			while(strcmp(s,";")!=0){
				i++;
				max=i;
				sa[i].lineno=line;
				fscanf(fn,"%s",s);
				strcpy(sa[i].var,s);
				if(strcmp(s,"=")==0){
					fscanf(fn,"%s",s);
					strcpy(sa[i].val,s);
				}
			}
		}
		fscanf(fn,"%s",s);
		if(strcmp(s,",")==0){
			continue;
		}
	} 
	for(i=1; i<=max; i++){
		printf("\n%s\t\t%s\t\t%d\t\t%s\n",sa[i].var,sa[i].dt,sa[i].lineno,sa[i].val);
	}
}







// SHIFT REDUCE PARSER
#include<stdio.h>
#include<string.h>
struct stack
{
	char s[20];
	int top;
};
struct stack st;

void disp(){	
	for(int i=0; i<st.top; i++){
		printf("%c",st.s[i]);
	}
}

int reduce(int *j,char rp[10][10],int n)
{	int i,t,k;
	char u[10];
	t=st.top-1;
	for (i=0; i<=st.top; i++){	
	    u[i]=st.s[t];
		for(k=0; k<n; k++){
			if(strcmp(rp[k],u)==0){
				st.top=st.top-i-1;
				return k;
			}
		}
		t--;
	}
}
int shift(char ip[],int *j){
    st.s[st.top++]=ip[*j];
	(*j)++;
	disp();
	return 1;
}

void newdisp(){
    for(k=j; k<strlen(ip); k++){
	     printf("%c",ip[k]);
    }
}

void main()
{	int n,i,j=0,k,h;
	char lp[10],ip[10],rp[10][10];
	scanf("%d",&n);
	for(i=0; i<n; i++){	 
		scanf(" %c",&lp[i]);
		scanf("%s",rp[i]);
	}
	scanf("%s",ip);
	
	printf("=================================================================");
	printf("\nSTACK INPUT OUTPUT");
	printf("\n================================================================\n");
	strcat(ip,"$");
	st.s[st.top++]='$';
	
	while(!(st.s[st.top-1]==lp[0]&&st.s[st.top-2]=='$'&&(j==(strlen(ip)-1))&&st.top==2)){
	    if((h=reduce(&j,rp,n))!=99){
	        st.s[st.top++]=lp[h];
	    	newdisp();
	    	printf("\t\t\tReduce %c->%s\n",lp[h],rp[h]);
	     }
	     else if(shift(ip,&j)){	 
	     	 newdisp();
	     	 printf("\t\t\tshift %c\n",ip[j-1]);
	     }
	}
	disp();
	newdisp()
	printf("\t\t\taccept\n");
}







// FRONTEND OF COMPILER
#include<stdio.h>
#include<ctype.h>
#include<string.h>
int ag=0,z=1;
void main()
{
	char a[50],id[50],b[50],op[50],mov[]="MOVF",mul[]="MULF",div[]="DIVF",add[]="ADDF",sub[]= "SUBF",ti=0;
	int i=0,j=0,k=0,len=0,s=0,e=0,r=1,count;
	FILE *fp;
	fp=fopen("out.txt","w");
	scanf("%s",a);
	strcpy(b,a);
	len=strlen(a);
	
	for ( i=0; i<strlen(b); i++ ) {
		if ( b[i] == '*' || b[i] == '/' ) {
			k=j+1;
			count=0;
			printf("\nt%d=",ti++);
			for ( j=j+1; count<2&&b[j]!='\0'; j++ ) {
				if ( b[j+1] == '+' || b[j+1] == '-' || b[j+1] == '*' || b[j+1] == '/' )
					count++;
			}
			b[k++]='t';
			b[k++]=ti-1+48;
			for ( j=j,k=k; k<strlen(b); k++,j++ )
				b[k]=b[j];
			i=0;
		}
	}
	for ( i=0; i<strlen(b); i++ ) {
		if ( b[i] == '+' || b[i] == '-' ) {
			k=j+1;
			count=0;
			printf("\nt%d=",ti++);
			for ( j=j+1; count<2&&b[j]!='\0'; j++ ){
				if ( b[j+1] == '+' || b[j+1] == '-' )
					count++;
				printf("%c",b[j]);
			}
			b[k++]='t';
			b[k++]=ti-1+48;
			for ( j=j,k=k; k<strlen(b); k++,j++ )
				b[k]=b[j];
		}
	}
	printf("\n%s",b);
}







// BACKEND OF COMPILER
#include<stdio.h>
#include<ctype.h>
#include<string.h>
int ag=0,z=1;

void printt(){
    e=a[i-1];
	if(a[i+1]=='i'){
		fprintf(fp,"R%c,R%c",(a[i+3]-1),s);
	}
	else{
		fprintf(fp,"R%c,R%d",e,r-1);
	}
}
void main()
{
	char
	a[50],id[50],mov[]="MOVF",mul[]="MULF",div[]="DIVF",add[]="ADDF",sub[]="SUBF";
	int i=0,j=0,len=0,s=0,e=0,r=1;
	FILE *fp;
	fp=fopen("out.txt","w");
	gets(a);
	len=strlen(a);
	
	for(i=0; i<len; i++){
		if(a[i]=='='){
			for(j=i; j<len; j++)
				if(a[j]=='i'){
					fprintf(fp,"\n%s ",mov);
					fprintf(fp,"%c%c%c,R%d",a[j],a[j+1],a[j+2],r++);
				}
		}
		else if((a[i]<=57)&&(a[i]>=48)){
			if((a[i+1]<=57)&&(a[i+1]>=48)){
				fprintf(fp,"\n%s #%c%c,R%d",mov,a[i],a[i+1],r++);
			}
		}
	}
	for(i=len-1; i>=0; i--)	{
		if(a[i]=='+'){
			fprintf(fp,"\n%s ",add);
			printt();
		}
		else if(a[i]=='-'){
			fprintf(fp,"\n%s ",sub);
			printt();
		}
		else if(a[i]=='*'){
			fprintf(fp,"\n%s ",mul);
			printt();
		}
		else if(a[i]=='/'){
			fprintf(fp,"\n%s ",div);
			printt();
		}
	}
	fprintf(fp,"\n%s R1,id1",mov);
}








// CODE OPTIMIZER
#include <stdio.h>
#include <string.h>
#define MAX 10

struct op {
    char l;      
    char r[20];  
};
struct op op[10],pr[10];
void main()
{
    int a,i,k,j,n,z=0,m,q;
    char *p,*l,*tem,temp,t;
    char nu[]="\0";
    
    scanf("%d",&n);
    for(i=0;i<n;i++)    {
        scanf(" %c",&op[i].l);
        scanf(" %s",op[i].r);
    }

    for(i=0;i<n;i++){
        printf("%c=%s\n",op[i].l,op[i].r);
    }
    for(i=0;i<n;i++){
        temp=op[i].l;
        p=NULL;
        for(j=0;j<n;j++){
            p=strchr(op[j].r,temp);
            if(p){
                pr[z].l=op[i].l;
                strcpy(pr[z].r,op[i].r);
                z++;
                break;
            }
        }
    }

    for(k=0;k<z;k++){
        printf("%c\t=%s\n",pr[k].l,pr[k].r);
    }
    for(m=0;m<z;m++)
    {
        tem=pr[m].r;
        for(j=m+1;j<z;j++)
        {
            p=strstr(tem,pr[j].r);
            if(p)
            {
                pr[j].l=pr[m].l;
                for(i=0;i<z;i++){
                    if(l){
                        a=l-pr[i].r;
                        pr[i].r[a]=pr[m].l;
                    }
                }
            }
        }
    }
    
    for(i=0;i<z;i++){
        printf("%c\t=%s\n",pr[i].l,pr[i].r);
    }
    
    for(i=0;i<z;i++){
        if(pr[i].l!='\0'){
             printf("%c\t=%s\n",pr[i].l,pr[i].r);
        }
    }
}